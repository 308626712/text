// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package gen contains common code for the various code generation tools in the
// text repository. Its usage ensures consistency between tools.
//
// This package defines command line flags that are common to most generation
// tools. The flags allow for specifying specific Unicode and CLDR versions
// in the public Unicode data repository (http://www.unicode.org/Public).
//
// A local Unicode data mirror can be set through the flag -local or the
// environment variable UNICODE_DIR. The former takes precedence. The local
// directory should follow the same structure as the public repository.
//
// IANA data can also optionally be mirrored by putting it in the iana directory
// rooted at the top of the local mirror. Beware, though, that IANA data is not
// versioned. So it is up to the developer to use the right version.
package gen

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"unicode"

	"golang.org/x/text/cldr"
)

var (
	url = flag.String("url",
		"http://www.unicode.org/Public",
		"URL of Unicode database directory")
	iana = flag.String("iana",
		"http://www.iana.org",
		"URL of the IANA repository")
	unicodeVersion = flag.String("unicode", unicode.Version, "unicode version to use")
	cldrVersion    = flag.String("cldr", cldr.Version, "cldr version to use")
	// Allow an environment variable to specify the local directory.
	// go generate doesn't allow specifying arguments; this is a useful
	// alternative to specifying a local mirror.
	localDir = flag.String("local",
		os.Getenv("UNICODE_DIR"),
		"directory containing local data files; for debugging only.")
)

// Init performs common initialization for a gen command. It parses the flags
// and sets up the standard logging parameters.
func Init() {
	log.SetPrefix("")
	log.SetFlags(log.Lshortfile)
	flag.Parse()
	UnicodeVersion = *unicodeVersion
	CLDRVersion = *cldrVersion
}

const header = `// This file was generated by go generate; DO NOT EDIT

package %s

`

// TODO: generate standardized version info.

var (
	UnicodeVersion string
	CLDRVersion    string
)

// IsLocal reports whether the user specified a local directory.
func IsLocal() bool {
	return *localDir != ""
}

// OpenUCDFile opens the requested UCD file. The file is specified relative to
// the public Unicode root directory. It will call log.Fatal if there are any
// errors.
func OpenUCDFile(file string) io.ReadCloser {
	return openUnicode(path.Join(*unicodeVersion, "ucd", file))
}

// OpenCLDRCoreZip opens the CLDR core zip file. It will call log.Fatal if there
// are any errors.
func OpenCLDRCoreZip() io.ReadCloser {
	return openUnicode(path.Join("cldr", *cldrVersion, "core.zip"))
}

// OpenIANAFile opens the requested IANA file. The file is specified relative
// to the IANA root, which is typically either http://www.iana.org or the
// iana directory in the local mirror. It will call log.Fatal if there are any
// errors.
func OpenIANAFile(path string) io.ReadCloser {
	if *localDir != "" {
		path = filepath.FromSlash(path)
		if f, err := os.Open(filepath.Join(*localDir, "iana", path)); err == nil {
			return f
		}
	}
	return get(*iana, path)
}

func openUnicode(path string) io.ReadCloser {
	if *localDir != "" {
		path = filepath.FromSlash(path)
		f, err := os.Open(filepath.Join(*localDir, path))
		if err != nil {
			log.Fatal(err)
		}
		return f
	}
	return get(*url, path)
}

func get(root, path string) io.ReadCloser {
	url := root + "/" + path
	resp, err := http.Get(url)
	if err != nil {
		log.Fatalf("HTTP GET: %v", err)
	}
	if resp.StatusCode != 200 {
		log.Fatalf("Bad GET status for %q: %q", url, resp.Status)
	}
	return resp.Body
}

// WriteHeader writes a file comment for a generated file and a package statement.
func WriteHeader(w io.Writer, pkg string) error {
	_, err := fmt.Fprintf(w, header, pkg)
	return err
}

// NewFormattedFileWriter returns a WriteCloser to which Go files can be written.
// The written Go code will be formatted with the -s option. It also writes a
// standard header to inform the users that this file was generated.
// It will call log.Fatal if there are any errors.
func NewFormattedFileWriter(filename, pkg string) io.WriteCloser {
	w := &formattedWriter{&bytes.Buffer{}, filename}
	WriteHeader(w, pkg)
	return w
}

type formattedWriter struct {
	w        *bytes.Buffer
	filename string
}

func (fw *formattedWriter) Write(b []byte) (n int, err error) {
	return fw.w.Write(b)
}

func (fw *formattedWriter) Close() error {
	b := fw.w.Bytes()
	formatted, err := format.Source(b)
	if err != nil {
		// Print the original buffer even in case of an error so that the
		// returned error can be meaningfully interpreted.
		ioutil.WriteFile(fw.filename, b, 0644)
		log.Fatalf("Error formatting file %s: %v", fw.filename, err)
	}
	return ioutil.WriteFile(fw.filename, formatted, 0644)
}
